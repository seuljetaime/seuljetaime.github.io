# 待清理代码

+ application.yml中的test open-url



# 期望结果

1. 请求正在执行的，继续执行，正常返回
2. 新的请求进不来，不受理



# 测试代码

编写一个GET API，在逻辑里面`Thread.sleep(10000L)`或者循环300亿次（如果太快或太慢，请自行调整）。然后验证关闭项目时，对此API有什么影响。

代码片段

```java
@GetMapping("/test")
public Map<String, Double> test() {
    long startTime = System.currentTimeMillis();

    logger.info("进入test");
    long l = 300 * 100000000L;
    while (l > 0) {
        l--;
    }

    Map<String, Double> resultMap = new HashMap<>();
    long endTime = System.currentTimeMillis();
    double gap = (endTime - startTime) / 1000.00;

    logger.info("test返回，耗时： " + gap);
    resultMap.put("test", gap);

    return resultMap;
}
```



# 方式一： kill

```
ps -ef | grep java
# 或者根据你的jar包名称，如果是使用java -jar service-platform.jar 启动的话
ps -ef | grep platform

kill ps返回的id
```



## 内嵌Undertow

kill进程会导致项目直接断开所有Http连接。kill时还在执行的请求会继续执行它们的逻辑，kill的进程不会立即关闭，要等这些逻辑执行完。但逻辑返回时，http连接已断开，无法将结果返回给调用者。

**已测试环境**

1. Windows + Intellij IDEA Debug项目
2. Intellij IDEA terminal 执行java -jar
3. Linux java -jar 执行项目
4. Linux kill `nohup java -jar xxx.jar &`

结果都是项目立即断开链接，curl及postman调用者都直接返回了，但无法获取服务器的返回结果，kill 的进程要等测试的循环执行完才关闭。

## 内嵌Tomcat

tomcat不会立即停。

+ 当while 300亿次，请求需执行超过9秒之后（可能是10秒，没验证精确值，要看源码才知道），后面的logger.info都没输出，log也没写入日志文件。postman大约需要3秒左右才显示“无法获取服务器返回结果”。

+ 当while 200亿次，请求需执行7，8秒，后面的logger会正常输出。postman大约需要3秒左右才显示“无法获取服务器返回结果”（没验证具体是3秒还是5秒，要看源码）。
+ 当while 60亿次，请求需执行2.4秒左右才处理完，这时postman及项目都能正确显示信息。

# 方式二： kill -9（不推荐）

这种方式相当于直接拔电源，项目、进程会立即关闭，正在跑的业务线程也会立即关闭。

应当在kill无法关闭项目后，再使用kill -9 强制杀死项目进程。

```
kill -9 进程id
```

# 编写Application ClosedEvent

## Tomcat版

1. 新请求会无法请求
2. 已请求的会继续执行，但超过30秒还未执行完，会强制关闭

```java
package com.gzkit.backend;

import com.gzkit.backend.config.KitPropsConfig;
import com.gzkit.backend.utils.ServiceInfoUtils;
import org.apache.catalina.connector.Connector;
import org.apache.tomcat.util.threads.ThreadPoolExecutor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.boot.web.embedded.tomcat.TomcatConnectorCustomizer;
import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Bean;
import org.springframework.context.event.ContextClosedEvent;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

/**
 * 程序主入口类
 *
 * @author bernix
 */
@SpringBootApplication
@EnableConfigurationProperties(KitPropsConfig.class)
public class ServiceMvcApplication {

    public static void main(String[] args) {
        SpringApplication.run(ServiceMvcApplication.class, args);
        System.out.println("Api地址:");
        int port = ServiceInfoUtils.getPort();
        System.out.println("http://localhost:" + port + "/api/swagger-ui.html");
        try {
            System.out.println("http://" + InetAddress.getLocalHost().getHostAddress() + ":" + port + "/api/swagger-ui.html");
        } catch (UnknownHostException e) {
            System.out.println("获取本机ip失败");
            e.printStackTrace();
        }
    }

    @Bean
    public GracefulShutdown gracefulShutdown() {
        return new GracefulShutdown();
    }

    @Bean
    public WebServerFactoryCustomizer tomcatCustomizer() {
        return factory -> {
            if (factory instanceof TomcatServletWebServerFactory) {
                ((TomcatServletWebServerFactory) factory)
                        .addConnectorCustomizers(gracefulShutdown());
            }
        };
    }

    /**
     * 优雅地关闭tomcat
     * https://github.com/spring-projects/spring-boot/issues/4657
     */
    private static class GracefulShutdown implements TomcatConnectorCustomizer,
            ApplicationListener<ContextClosedEvent> {

        private static final Logger log = LoggerFactory.getLogger(GracefulShutdown.class);

        private volatile Connector connector;

        @Override
        public void customize(Connector connector) {
            this.connector = connector;
        }

        @Override
        public void onApplicationEvent(ContextClosedEvent event) {
            Executor executor = this.connector.getProtocolHandler().getExecutor();
            if (executor instanceof ThreadPoolExecutor) {
                try {
                    ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executor;
                    threadPoolExecutor.shutdown();
                    if (!threadPoolExecutor.awaitTermination(30, TimeUnit.SECONDS)) {
                        log.warn("Tomcat thread pool did not shut down gracefully within "
                                + "30 seconds. Proceeding with forceful shutdown");
                    }
                } catch (InterruptedException ex) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }

}
```

## Undertown版

1. 新请求会返回503
2. 已请求的会继续执行，超过30秒的会断开连接，postman在30秒左右时会看到“Could not get any response”。但后台进程会继续执行那些超过30秒的任务，结果返回时提示Stream is closed

```java
package com.gzkit.backend;

import com.gzkit.backend.config.KitPropsConfig;
import com.gzkit.backend.utils.ServiceInfoUtils;
import io.undertow.server.HandlerWrapper;
import io.undertow.server.HttpHandler;
import io.undertow.server.handlers.GracefulShutdownHandler;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.boot.web.embedded.undertow.UndertowServletWebServerFactory;
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Bean;
import org.springframework.context.event.ContextClosedEvent;

import java.net.InetAddress;
import java.net.UnknownHostException;

/**
 * 程序主入口类
 *
 * @author bernix
 */
@SpringBootApplication
@EnableConfigurationProperties(KitPropsConfig.class)
public class ServiceMvcApplication {

    public static void main(String[] args) {
        SpringApplication.run(ServiceMvcApplication.class, args);
        System.out.println("Api地址:");
        int port = ServiceInfoUtils.getPort();
        System.out.println("http://localhost:" + port + "/api/swagger-ui.html");
        try {
            System.out.println("http://" + InetAddress.getLocalHost().getHostAddress() + ":" + port + "/api/swagger-ui.html");
        } catch (UnknownHostException e) {
            System.out.println("获取本机ip失败");
            e.printStackTrace();
        }
    }

    @Bean
    public GracefulUndertowShutdown GracefulUndertowShutdown() {
        return new GracefulUndertowShutdown();
    }

    /**
     * 优雅地关闭undertow
     * https://github.com/spring-projects/spring-boot/issues/4657
     */
    @Bean
    public WebServerFactoryCustomizer<UndertowServletWebServerFactory> undertowCustomizer() {
        return factory -> factory.addDeploymentInfoCustomizers((builder) -> {
            builder.addInitialHandlerChainWrapper(GracefulUndertowShutdown());
        });
    }

    private static class GracefulUndertowShutdown
            implements ApplicationListener<ContextClosedEvent>, HandlerWrapper {

        private volatile GracefulShutdownHandler handler;

        @Override
        public HttpHandler wrap(HttpHandler handler) {
            this.handler = new GracefulShutdownHandler(handler);
            return this.handler;
        }

        @Override
        public void onApplicationEvent(ContextClosedEvent event) {
            try {
                this.handler.shutdown();
                this.handler.awaitShutdown(30000);
            } catch (InterruptedException ex) {
                Thread.currentThread().interrupt();
            }
        }

    }

}
```

# 方式三： actuator shutdown

**步骤：**

1. 添加lib依赖`compile('org.springframework.boot:spring-boot-starter-actuator')`
2. 在application.yml中配置

```
management:
    endpoints:
        web:
            exposure:
                include: info, health, shutdown
    endpoint:
        shutdown:
            enabled: true
```

3. `/actuator`这个URL还需做认证，请见子章节
4. curl -X POST http://localhost:9898/api/actuator/shutdown`

此方式与方式一： kill的效果一样。默认都不能保证已请求的能正常获取返回结果。需要额外编写ClosedEvent。

## actuator 认证

1. 使用自定义Servlet Filter拦截/actuator（备注：无法使用HandlerInterceptorAdapter拦截）

   ```java
   @Bean
       public FilterRegistrationBean<TestFilter> authenticationFilterRegistration() {
           # TestFilter自行更名及编写逻辑，实现Filter
           FilterRegistrationBean<TestFilter> filterRegistrationBean =
                   new FilterRegistrationBean<>(new TestFilter());
           filterRegistrationBean.setUrlPatterns(Arrays.asList("/actuator", "/actuator/*"));
           return filterRegistrationBean;
       }
   ```

2. 继承WebMvcEndpointManagementContextConfiguration，设置拦截器

   ```java
   /**
    * https://github.com/spring-projects/spring-boot/issues/11234
    */
   @Configuration
   public class WebMvcConfig extends WebMvcEndpointManagementContextConfiguration {
   	@Override
       public WebMvcEndpointHandlerMapping webEndpointServletHandlerMapping(WebEndpointsSupplier webEndpointsSupplier, ServletEndpointsSupplier servletEndpointsSupplier, ControllerEndpointsSupplier controllerEndpointsSupplier, EndpointMediaTypes endpointMediaTypes, CorsEndpointProperties corsProperties, WebEndpointProperties webEndpointProperties) {
           WebMvcEndpointHandlerMapping mapping = super.webEndpointServletHandlerMapping(webEndpointsSupplier, servletEndpointsSupplier, controllerEndpointsSupplier, endpointMediaTypes, corsProperties, webEndpointProperties);
           # authorizationInterceptor() 自定义继承HandlerInterceptorAdapter
           mapping.setInterceptors(authorizationInterceptor());
           return mapping;
       }
   }
   ```

3. spring-security 自行查找



# Nginx负载时更新项目

**要求：**

1. 现有连接正常执行
2. 新请求不会被拒绝

**部署步骤：**

1. 停止一个负载节点，并更新此节点
2. 重启已更新的节点
3. 停止其他节点，以上面两步循环

## JMeter压力测试

编写JMeter压力测试，每秒20请求，请求的API主要就sleep10秒，需调整undertow的work-threads数为300。保证每秒20次的请求都被受理，不会被其他sleep阻塞。