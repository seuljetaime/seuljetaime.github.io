---
title: Spring Boot 优雅地停止项目
date: 2019-01-11 15:05:21
tags: Spring Boot
---


# 期望结果

1. 请求正在执行的，继续执行，正常返回
2. 新的请求进不来，不受理



<!-- more -->



# 测试代码

编写一个API，在逻辑里面`Thread.sleep(10000)`或者循环300亿次（如果太快或太慢，请自行调整）。然后验证关闭项目时，对此API有什么影响。

代码片段

```java
@PostMapping("/test/{index}")
public Map<String, Object> test(@PathVariable Integer index, String p) throws InterruptedException {
    long startTime = System.currentTimeMillis();

    logger.info("进入test " + index + " p: " + p);
    Thread.sleep(10000);

    Map<String, Object> resultMap = new HashMap<>();
    long endTime = System.currentTimeMillis();
    double gap = (endTime - startTime) / 1000.00;

    logger.info("test " + index + " 返回，耗时： " + gap);
    resultMap.put("test", gap + " index: " + index);

    return resultMap;
}
```



# 方式一： kill

```
ps -ef | grep java
# 或者根据你的jar包名称，如果是使用java -jar graceful.jar 启动的话
ps -ef | grep graceful

kill ps返回的id
```



## 内嵌Undertow

kill进程会导致项目直接断开所有Http连接。kill时还在执行的请求会继续执行它们的逻辑，kill的进程不会立即关闭，要等这些逻辑执行完。但逻辑返回时，http连接已断开，无法将结果返回给调用者。

**已测试环境**

1. Windows + Intellij IDEA Debug项目
2. Intellij IDEA terminal 执行java -jar
3. Linux java -jar 执行项目
4. Linux kill `nohup java -jar xxx.jar &`

结果都是项目立即断开链接，curl及postman调用者都直接返回了，无法获取服务器的返回结果，kill 的进程要等测试的循环执行完才关闭。

## 内嵌Tomcat

tomcat不会立即停。

+ 当while 300亿次，请求需执行超过9秒之后（可能是10秒，没验证精确值，要看源码才知道），后面的logger.info都没输出，log也没写入日志文件。postman大约需要3秒左右才显示“无法获取服务器返回结果”。
+ 当while 200亿次，请求需执行7，8秒，后面的logger会正常输出。postman大约需要3秒左右才显示“无法获取服务器返回结果”（没验证具体是3秒还是5秒，要看源码）。
+ 当while 60亿次，请求需执行2.4秒左右才处理完，这时postman及项目都能正确显示信息。



## 编写Application ClosedEvent

### Tomcat版

1. 新请求会无法请求
2. 已请求的会继续执行，但超过30秒还未执行完，会强制关闭

```java

import org.apache.catalina.connector.Connector;
import org.apache.tomcat.util.threads.ThreadPoolExecutor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.boot.web.embedded.tomcat.TomcatConnectorCustomizer;
import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Bean;
import org.springframework.context.event.ContextClosedEvent;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

/**
 * 程序主入口类
 */
@SpringBootApplication
@EnableConfigurationProperties(PropsConfig.class)
public class ServiceMvcApplication {

    public static void main(String[] args) {
        SpringApplication.run(ServiceMvcApplication.class, args);
    }

    @Bean
    public GracefulShutdown gracefulShutdown() {
        return new GracefulShutdown();
    }

    @Bean
    public WebServerFactoryCustomizer tomcatCustomizer() {
        return factory -> {
            if (factory instanceof TomcatServletWebServerFactory) {
                ((TomcatServletWebServerFactory) factory)
                        .addConnectorCustomizers(gracefulShutdown());
            }
        };
    }

    /**
     * 优雅地关闭tomcat
     * https://github.com/spring-projects/spring-boot/issues/4657
     */
    private static class GracefulShutdown implements TomcatConnectorCustomizer,
            ApplicationListener<ContextClosedEvent> {

        private static final Logger log = LoggerFactory.getLogger(GracefulShutdown.class);

        private volatile Connector connector;

        @Override
        public void customize(Connector connector) {
            this.connector = connector;
        }

        @Override
        public void onApplicationEvent(ContextClosedEvent event) {
            Executor executor = this.connector.getProtocolHandler().getExecutor();
            if (executor instanceof ThreadPoolExecutor) {
                try {
                    ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executor;
                    threadPoolExecutor.shutdown();
                    if (!threadPoolExecutor.awaitTermination(30, TimeUnit.SECONDS)) {
                        log.warn("Tomcat thread pool did not shut down gracefully within "
                                + "30 seconds. Proceeding with forceful shutdown");
                    }
                } catch (InterruptedException ex) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }

}
```

### Undertown版

1. 新请求会返回503
2. 已请求的会继续执行，超过30秒的会断开连接，postman在30秒左右时会看到“Could not get any response”。但后台进程会继续执行那些超过30秒的任务，结果返回时提示Stream is closed

```java

import io.undertow.server.HandlerWrapper;
import io.undertow.server.HttpHandler;
import io.undertow.server.handlers.GracefulShutdownHandler;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.boot.web.embedded.undertow.UndertowServletWebServerFactory;
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Bean;
import org.springframework.context.event.ContextClosedEvent;

import java.net.InetAddress;
import java.net.UnknownHostException;

/**
 * 程序主入口类
 */
@SpringBootApplication
@EnableConfigurationProperties(PropsConfig.class)
public class ServiceMvcApplication {

    public static void main(String[] args) {
        SpringApplication.run(ServiceMvcApplication.class, args);
    }

    @Bean
    public GracefulUndertowShutdown GracefulUndertowShutdown() {
        return new GracefulUndertowShutdown();
    }

    /**
     * 优雅地关闭undertow
     * https://github.com/spring-projects/spring-boot/issues/4657
     */
    @Bean
    public WebServerFactoryCustomizer<UndertowServletWebServerFactory> undertowCustomizer() {
        return factory -> factory.addDeploymentInfoCustomizers((builder) -> {
            builder.addInitialHandlerChainWrapper(GracefulUndertowShutdown());
        });
    }

    private static class GracefulUndertowShutdown
            implements ApplicationListener<ContextClosedEvent>, HandlerWrapper {

        private volatile GracefulShutdownHandler handler;

        @Override
        public HttpHandler wrap(HttpHandler handler) {
            this.handler = new GracefulShutdownHandler(handler);
            return this.handler;
        }

        @Override
        public void onApplicationEvent(ContextClosedEvent event) {
            try {
                this.handler.shutdown();
                this.handler.awaitShutdown(30000);
            } catch (InterruptedException ex) {
                Thread.currentThread().interrupt();
            }
        }

    }

}
```



# 方式二： kill -9（不推荐）

这种方式相当于直接拔电源，项目、进程会立即关闭，正在跑的业务线程也会立即关闭。

应当在kill无法关闭项目后，再使用kill -9 强制杀死项目进程。

```
kill -9 进程id
```



# 方式三： actuator shutdown

**步骤：**

1. 添加lib依赖`compile('org.springframework.boot:spring-boot-starter-actuator')`
2. 在application.yml中配置

```
management:
    endpoints:
        web:
            exposure:
                include: info, health, shutdown
    endpoint:
        shutdown:
            enabled: true
```

3. `/actuator`这个URL还需做认证，请见子章节
4. curl -X POST `http://localhost:9898/api/actuator/shutdown`

**此方式与方式一： kill的效果一样。默认都不能保证已请求的能正常获取返回结果。需要额外编写ClosedEvent。**



## actuator 认证

1. 使用自定义Servlet Filter拦截/actuator（备注：无法使用HandlerInterceptorAdapter拦截）

   ```java
   @Bean
   public FilterRegistrationBean<TestFilter> authenticationFilterRegistration() {
       # TestFilter自行更名及编写逻辑，实现Filter
           FilterRegistrationBean<TestFilter> filterRegistrationBean =
           new FilterRegistrationBean<>(new TestFilter());
       filterRegistrationBean.setUrlPatterns(Arrays.asList("/actuator", "/actuator/*"));
       return filterRegistrationBean;
   }
   ```

2. 继承WebMvcEndpointManagementContextConfiguration，设置拦截器

   ```java
   /**
    * https://github.com/spring-projects/spring-boot/issues/11234
    */
   @Configuration
   public class WebMvcConfig extends WebMvcEndpointManagementContextConfiguration {
   	@Override
       public WebMvcEndpointHandlerMapping webEndpointServletHandlerMapping(WebEndpointsSupplier webEndpointsSupplier, ServletEndpointsSupplier servletEndpointsSupplier, ControllerEndpointsSupplier controllerEndpointsSupplier, EndpointMediaTypes endpointMediaTypes, CorsEndpointProperties corsProperties, WebEndpointProperties webEndpointProperties) {
           WebMvcEndpointHandlerMapping mapping = super.webEndpointServletHandlerMapping(webEndpointsSupplier, servletEndpointsSupplier, controllerEndpointsSupplier, endpointMediaTypes, corsProperties, webEndpointProperties);
           # authorizationInterceptor() 自定义继承HandlerInterceptorAdapter
           mapping.setInterceptors(authorizationInterceptor());
           return mapping;
       }
   }
   ```

3. spring-security 自行查找



# Nginx负载时更新项目

**要求：**

1. 现有连接正常执行
2. 新请求不会被拒绝

**部署步骤：**

1. 启用两个jar，nginx作负载。此处将另一个jar的节点设置为backup，nginx作主从负载
2. 使用脚本持续请求接口
3. 停止一个负载节点，并更新此节点
4. 重启已更新的节点
5. 停止其他节点，以上面两步循环

## 持续请求接口

编写脚本测试，每秒发送一次后台curl POST请求，加`&`不阻断后续的curl发送。请求的后台API主要就sleep10秒。将undertow的work-threads数调整为100或更高。保证每秒1次的请求都被受理，不会被其他sleep阻塞。

```bash
i=0
while true
do
        let i++
        curl -X POST -F p=$i http://192.168.56.101:8080/api/v1/public/test/$i &
        let i++
        curl -X POST -F p=$i http://192.168.56.101:8080/api/v1/public/test/$i &
        let i++
        curl -X POST -F p=$i http://192.168.56.101:8080/api/v1/public/test/$i &
        sleep 1

done
```



也可以使用Jmeter等其他可视化工具

## 问题

1. 持续请求时，停止一个jar，nginx1.12.2会报503错误，在location中增加

`proxy_next_upstream error http_503;` 

后可以看到503的错误不见了，但停止jar的那一秒，有请求会报502，增加了

`proxy_next_upstream error http_502 http_503;` 后，还是502错误

2. 部署一个最新版的nginx1.14.2。配置`proxy_next_upstream error http_502 http_503;`后，出现大量的503错误，配置的http_503看起来没生效。

   需要在`proxy_next_upstream error http_502 http_503 non_idempotent;` 额外配置一个non_idempotent，让POST请求也重试，但查询到这样会有重复提交的问题。



## non_idempotent

[non_idempotent官方说明链接](https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream)

```
non_idempotent
normally, requests with a non-idempotent method (POST, LOCK, PATCH) are not passed to the next server if a request has been sent to an upstream server (1.9.13); enabling this option explicitly allows retrying such requests;
```

*重试尝试*

1. 启动两个jar节点，并用nginx负载
2. 配置Nginx proxy_next_upstream error http_502 http_503 non_idempotent;
3. 使用工具或脚本持续请求一个测试API，该API最好是接收PathVariable参数，可以通过URL方便验证是否重试了。本文中`测试代码`章节已列出一个POST请求
4. 在测试中关停、或kill -9 一个节点

*结果：*

+ 第一次测试：普通关停的没有将请求重试到另一个jar节点
+ 第二次测试：kill -9 的节点请求重试到了另一个jar节点

node1日志：

```
2018-12-17 16:57:28.540  INFO 17621 --- [  XNIO-2 task-1] com.gzk.bac.api.PublicApi                : 进入test 1 p: 1
2018-12-17 16:57:38.541  INFO 17621 --- [  XNIO-2 task-1] com.gzk.bac.api.PublicApi                : test 1 返回，耗时： 10.001
2018-12-17 16:57:38.608  INFO 17621 --- [  XNIO-2 task-2] com.gzk.bac.api.PublicApi                : 进入test 12 p: 12
2018-12-17 16:57:39.418  INFO 17621 --- [  XNIO-2 task-3] com.gzk.bac.api.PublicApi                : 进入test 13 p: 13
2018-12-17 16:57:39.431  INFO 17621 --- [  XNIO-2 task-4] com.gzk.bac.api.PublicApi                : 进入test 14 p: 14
2018-12-17 16:57:40.412  INFO 17621 --- [  XNIO-2 task-5] com.gzk.bac.api.PublicApi                : 进入test 15 p: 15
2018-12-17 16:57:40.423  INFO 17621 --- [  XNIO-2 task-6] com.gzk.bac.api.PublicApi                : 进入test 16 p: 16
2018-12-17 16:57:41.405  INFO 17621 --- [  XNIO-2 task-7] com.gzk.bac.api.PublicApi                : 进入test 17 p: 17
2018-12-17 16:57:41.421  INFO 17621 --- [  XNIO-2 task-8] com.gzk.bac.api.PublicApi                : 进入test 18 p: 18
2018-12-17 16:57:42.404  INFO 17621 --- [  XNIO-2 task-9] com.gzk.bac.api.PublicApi                : 进入test 19 p: 19
2018-12-17 16:57:42.419  INFO 17621 --- [ XNIO-2 task-10] com.gzk.bac.api.PublicApi                : 进入test 20 p: 20
```

node2日志：

```
2018-12-17 16:57:34.408  INFO 17354 --- [ XNIO-2 task-90] com.gzk.bac.api.PublicApi                : 进入test 7 p: 7
2018-12-17 16:57:35.390  INFO 17354 --- [ XNIO-2 task-91] com.gzk.bac.api.PublicApi                : 进入test 8 p: 8
2018-12-17 16:57:36.394  INFO 17354 --- [ XNIO-2 task-92] com.gzk.bac.api.PublicApi                : 进入test 9 p: 9
2018-12-17 16:57:37.394  INFO 17354 --- [ XNIO-2 task-93] com.gzk.bac.api.PublicApi                : 进入test 10 p: 10
2018-12-17 16:57:38.386  INFO 17354 --- [ XNIO-2 task-94] com.gzk.bac.api.PublicApi                : 进入test 11 p: 11
2018-12-17 16:57:39.399  INFO 17354 --- [ XNIO-2 task-85] com.gzk.bac.api.PublicApi                : test 2 返回，耗时： 10.005
2018-12-17 16:57:40.389  INFO 17354 --- [ XNIO-2 task-86] com.gzk.bac.api.PublicApi                : test 3 返回，耗时： 10.001
2018-12-17 16:57:41.393  INFO 17354 --- [ XNIO-2 task-87] com.gzk.bac.api.PublicApi                : test 4 返回，耗时： 10.002
2018-12-17 16:57:42.393  INFO 17354 --- [ XNIO-2 task-88] com.gzk.bac.api.PublicApi                : test 5 返回，耗时： 10.001
2018-12-17 16:57:42.463  INFO 17354 --- [ XNIO-2 task-95] com.gzk.bac.api.PublicApi                : 进入test 13 p: 13
2018-12-17 16:57:42.465  INFO 17354 --- [ XNIO-2 task-96] com.gzk.bac.api.PublicApi                : 进入test 15 p: 15
2018-12-17 16:57:42.467  INFO 17354 --- [ XNIO-2 task-97] com.gzk.bac.api.PublicApi                : 进入test 17 p: 17
2018-12-17 16:57:42.468  INFO 17354 --- [ XNIO-2 task-98] com.gzk.bac.api.PublicApi                : 进入test 19 p: 19
2018-12-17 16:57:42.469  INFO 17354 --- [ XNIO-2 task-99] com.gzk.bac.api.PublicApi                : 进入test 12 p: 12
2018-12-17 16:57:42.471  INFO 17354 --- [  XNIO-2 task-1] com.gzk.bac.api.PublicApi                : 进入test 16 p: 16
2018-12-17 16:57:42.472  INFO 17354 --- [  XNIO-2 task-2] com.gzk.bac.api.PublicApi                : 进入test 18 p: 18
2018-12-17 16:57:42.472  INFO 17354 --- [  XNIO-2 task-3] com.gzk.bac.api.PublicApi                : 进入test 20 p: 20
2018-12-17 16:57:42.473  INFO 17354 --- [XNIO-2 task-100] com.gzk.bac.api.PublicApi                : 进入test 14 p: 14
2018-12-17 16:57:43.397  INFO 17354 --- [  XNIO-2 task-4] com.gzk.bac.api.PublicApi                : 进入test 21 p: 21
```



**发现有人提出`nginx -s reload`的方式**

## Nginx reload

nginx -s reload时是优雅的形式，启动新的worker，如果旧的worker有连接，则等连接完成后再关闭。这样我们就可以通过移除/禁用 一个jar节点，重启jar之后再加入的方式来更新。

[Nginx reload官方说明](http://nginx.org/en/docs/beginners_guide.html#control)

```
nginx -s reload

Once the master process receives the signal to reload configuration, it checks the syntax validity of the new configuration file and tries to apply the configuration provided in it. If this is a success, the master process starts new worker processes and sends messages to old worker processes, requesting them to shut down. Otherwise, the master process rolls back the changes and continues to work with the old configuration. Old worker processes, receiving a command to shut down, stop accepting new connections and continue to service current requests until all such requests are serviced. After that, the old worker processes exit.
```



```
[test@localhost nginx]$ ps -ef |grep nginx | grep -v grep
test      14911     1  0 16:42 ?        00:00:00 nginx: master process sbin/nginx
test      15395 14911  0 16:58 ?        00:00:00 nginx: worker process

# 注释掉一个upstream，reload
[test@localhost nginx]$ vim conf/nginx.conf
[test@localhost nginx]$ sbin/nginx -s reload

[test@localhost nginx]$ ps -ef |grep nginx | grep -v grep
test      14911     1  0 16:42 ?        00:00:00 nginx: master process sbin/nginx
test      15395 14911  0 16:58 ?        00:00:00 nginx: worker process is shutting down
test      15417 14911  0 16:59 ?        00:00:00 nginx: worker process
[test@localhost nginx]$ ps -ef |grep nginx | grep -v grep
test      14911     1  0 16:42 ?        00:00:00 nginx: master process sbin/nginx
test      15417 14911  0 16:59 ?        00:00:00 nginx: worker process
```

这样我们就可以通过修改upsteam server节点的方式来更新对应节点的项目。

# 其他问题

websocket的处理

